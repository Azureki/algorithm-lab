# <center>线性时间选择实验报告</center>

<center>2016201218 孙浩</center>  
我保证没有抄袭。

## 实验目的

实现线性时间选择算法并验证其时间复杂度。

## 问题

给定一个序列和一个数`k`，找出序列中第`k`小的元素。

## 算法设计与分析

参考快速排序中划分的思想。将序列划分为两部分，若左边长度大于`k`，则结果在左边，否则在右边。  
再对子问题继续使用该算法，问题规模为`1`时，算法必然终止。

``` py
def randomized_select(a, p, r, k):
    # 问题规模为1，已找到
    if p == r:
        return a[p]
    # 划分
    i = Linear0.randomized_partition(a, p, r)
    j = i - p + 1
    if k <= j:
        # 落在左边，递归调用
        return Linear0.randomized_select(a, p, i, k)
    else:
        # 落在右边
        return Linear0.randomized_select(a, i + 1, r, k - j)
```

### 算法分析

#### 时间复杂度

最坏情况下和快速排序一样，每次问题规模缩减`1`，所以复杂度是$O(N^2)$。平均情况是*O(N)*。

#### 空间复杂度

`3`个变量，复杂度为`O(1)`。

## 实验设计

不同问题规模下，使用随机数模块产生输入。  
查找第`k`小的元素，测试算法运行时间。

## 实验结果和分析

### 随机生成

采用python built-in module `random`, 生成随机数然后排序，作为输入。

`lst = [random.randrange(100) for _ in range(100)]`

问题规模$10^2$

    [0.043116578063091514]

问题规模$10^3$

    [0.5290357391986786]

问题规模$10^4$

    [4.832058133426977]

![线性时间选择](linear.png)

从图上来看，确实是线性时间。

## 总结

本次实验，手写实现了线性选择算法，加深了对递归以及分治的理解。学会了调用`python`的`random`库和`timeit`库，用来生成随机数和测试运行时间。并以此来验证了线性选择算法的时间复杂度。

但是，也仅此而已了。我因为时间（抑郁）的缘故，没有对线性时间选择算法进行优化（参见源代码，仍然是最简单的写法），因此这个实验做得不是很好。很多想做的没有完成。这也让我意识到人生苦短，不是用python就能改变的。
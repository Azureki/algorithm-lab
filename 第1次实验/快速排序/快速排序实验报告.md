# <center>快速排序实验报告</center>

<center>2016201218 孙浩</center>  
我保证没有抄袭。

## 实验目的

实现快速排序并验证其复杂度。

## 问题

给定一个序列，将其变为有序。

## 算法设计与分析

选择一个数，将序列划分为两部分，左边全部小于该数，右边全部大于该数。理想情况下左右的长度相等，都为序列总长度的一半，即$\frac N2$。

然后对左右两部分再使用该算法，直到问题规模缩减为`1`，算法停止。

算法实现如下：

``` py
def sort(lst, left, right):
    if left > right:
        return
    j = Quick.partition(lst, left, right)
    sort(lst, left, j - 1)
    sort(lst, j + 1, right)
```

### 算法分析

#### 时间复杂度

理想情况下每次变为一半，直至为`1`，所以时间复杂度是`O(NlogN)`。  
但是最坏情况下，每次规模只减少`1`，时间复杂度是$O(N^{2})$。

#### 空间复杂度

原地排序，空间复杂度`O(1)`。

## 实验设计

数据规模从小到大，使用随机数产生输入，测试算法的运行时间。

## 实验结果与分析

### 随机生成

采用python built-in module `random`, 生成一组随机数作为输入。

`lst = [random.randrange(1000) for _ in range(100)]`

输入序列的长度为$10^2$至$10^6$。

序列长度为$10^2$

    单位：ms
    [0.002663788929092359, 0.001729794957532227, 0.001457807702077929]

序列长度为$10^3$

    单位：s
    我的：[0.0028441362736792947, 0.0030827666015778928, 0.003724612537292861, 0.0029951588467886994, 0.0029478726527811423]
    平均：0.0031189093824239783
    内置：[0.00025769142935900814, 0.00017521550957838675, 0.00017998078494348932, 0.0003075435408708504, 0.00024486184183757813]
    平均：0.00023305862131786257

序列长度为$10^4$

    单位：s
    我的：[0.035168465313743895, 0.03763247923714539, 0.036780961185365904, 0.03585063281024049, 0.03620949470119708]
    平均：0.036328406649538555
    内置：[0.003921088506192476, 0.00030571074265350277, 0.0003123088162359528, 0.00032623808268779104, 0.0003313699176963631]

序列长度为$10^5$

    单位:s
    我的: [0.518384249078744, 0.4724660556606156, 0.4854624278198242, 0.46552964752724346, 0.4998766526799725]
    平均：0.48834380655327997
    内置：[0.03482756484531733, 0.004409712510937226, 0.003527770008749778]

序列长度为$10^6$

    单位：s
    我的：[6.098842441301888, 6.621401438160105, 6.459647831488132, 6.2213705005261986, 6.780679667559728]
    平均：6.436388375807209
    内置: [0.5867446901086446, 0.059041028654333805, 0.05878150442675745]

时间复杂度：

    Avg(T)/NlonN=
    [0.0000010000, 
    0.0000009000, 
    0.0000009760, 
    0.0000010717]

![柱状图](quick.png)

可以发现，常数因子为`k=0.000001`，因此，算法的时间复杂度为$\Theta(Nlog(N))$
因为是随机输入，所以快排的平均复杂度确实是$\Theta(O(NlogN))$。

### 比较

做到这里我才想起我是用的`CPython`，内置库最终是用C实现的，所以才会有$10^2$倍的差距……而我手写的是python代码，so……

## 总结

本次实验，手写实现了快速排序算法，加深了对递归的理解。学会了调用`python`的`random`库和`timeit`库，用来生成随机数和测试运行时间。并以此来验证了快速排序算法的平均时间复杂度。

当然，针对快排的优化是存在的。只是我现在还想不到什么办法和内置库来比较，也想不到什么显著的方法提升性能。